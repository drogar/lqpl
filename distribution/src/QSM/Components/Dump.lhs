%include polycode.fmt
\subsection{Description of the dump}
The  quantum stack machine has a |Dump|, used by various
instructions to hold intermediate states of the machine.
%if false
\begin{code}
module QSM.Components.Dump
    (DumpElement(..),
     showDumpTop,
     trimDump,
     Dump)
    where
import QSM.BasicData
import QSM.Components.ClassicalStack
import QSM.Components.Instructions
import QSM.Components.MemoryMap
import QSM.Transformations
import Data.ClassComp
import QSM.QuantumStack.QSDefinition
import Data.Map as Map
import Data.Array as Array
import QSM.QuantumStack.QSManipulation(trimStack)
import Data.Tuples
import Data.List as List
\end{code}
%endif

Another essential part of the machine is the |Dump|
which is used
when working with |Use|, |Split|, |Measure| and |Call|.

At version 7.3, once the Quantum Stack address became
fully generated by the machine, the pieces needed for
management of that generation needed to be included in the
dump for the stack splitting operations. This meant
adding the |MemoryMap| and |NameSupply| to the
|DumpStackSplit| constructor.

%%%%Thesis dumpDefinition
{\begin{figure}[htbp]
\begin{singlespace}
\begin{code}

data DumpElement b =
          DumpStackSplit {
                     returnLabel :: Label,
                     branchesToDo:: [(QuantumStack b, Label)],
                     resultQStack :: QuantumStack b,
                     saveClsStack :: ClassicalStack,
                     saveNS :: NameSupply,
                     resultNS :: NameSupply,
                     saveStrans :: MemoryMap,
                     resultStrans :: MemoryMap}|
          DumpCall { returnLabel :: Label,
                     returnEp :: EntryPoint,
                     saveClsStack ::ClassicalStack}
          deriving  Show

type Dump b = [DumpElement b]

\end{code}
\end{singlespace}
\caption{Haskell definition of the Dump}\label{fig:haskellDefinitionOfDump}
\end{figure}}
 The |DumpElement| for the first three types, |DumpStackSplit|, provides
all that is needed to complete those instructions on the various branches
of a |Split, Use| or |Measure|. It has the following items:
\begin{itemize}
\item{} |returnLabel|: The |Label| to continue with when the
instruction is complete. This is normally the instruction
following the quantum control.
\item{} |saveClsStack|: As the |ClassicalStack| is reset before each
invocation of a branch and then restored after all are completed,
it is saved here.
\item{} |resultQStack|: As the partial branches are processed,
the  resulting quantum stacks are accumulated, merging after each branch.
\item{} |branchesToDo|: This is a list of pairs, whose first item is
 derived from the quantum stack. Each one is a single branched
|Qstack|.  The second item in the pair is the label for the code
to execute at this point. Note that in the the
case of |Use| for integers, it would have been possible to simply use
 a single label as all
branches execute the same code. However, doing it this way allows for a
single data element for Quantum Control.
\end{itemize}

%if false
\begin{code}

showDumpEl :: (Show b)=>DumpElement b -> String
showDumpEl d@(DumpStackSplit _ _ _ _ _ _ _ _)
  =  "Stack Splitting: { \n"
        ++ " returnTo :" ++ show (returnLabel d) ++ "\n"
        ++ " branches remaining :" ++ show (length $ branchesToDo d) ++ "\n"
        ++ showList (branchesToDo d) ""
        ++ " saved Classical :" ++ show (saveClsStack d) ++ "\n"
        ++ " current result :" ++ show (resultQStack d) ++ "\n"
        ++ " Result NameSupply :" ++ show (resultNS d) ++ "\n"
        ++ " Result StackTrans :" ++ show (resultStrans d) ++ "\n"
        ++ "}"

showDumpEl (d@(DumpCall _ _ _))
   = "Call: { \n"
        ++ " returnTo :" ++ returnEp d ++ ";"
               ++ show (returnLabel d) ++ "\n"
        ++ " saved Classical :" ++ show (saveClsStack d) ++ "\n"
        ++ "}"

showDumpTop :: (Show b)=>Dump b -> String
showDumpTop = showDumpTop' 15

showDumpTop' :: (Show b)=>Int->Dump b -> String
showDumpTop' _ [] = "Empty Dump"
showDumpTop' 0 (d:ds)
   = showDumpEl d
        ++ " + "++ show (length ds) ++ " Remaining dump elements."
showDumpTop' n (d:ds)
   = showDumpEl d ++"\n"++ showDumpTop' (n-1) ds

trimDump :: (Quantum b) => (Maybe Int) -> Dump b -> Dump b
trimDump  = List.map . trimDumpElement

trimDumpElement :: (Quantum b) => (Maybe Int) -> DumpElement b -> DumpElement b
trimDumpElement _ d@(DumpCall _ _ _)   = d
trimDumpElement eps (DumpStackSplit rl brnchs res cls sns rns sst rst)
    = DumpStackSplit rl (List.map (app1of2 (trimStack eps)) brnchs)
                (trimStack eps res) cls sns rns sst rst

\end{code}
%endif

